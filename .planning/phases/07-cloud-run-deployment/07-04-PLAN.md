---
phase: 07-cloud-run-deployment
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/knowledge_hub/digest.py
  - src/knowledge_hub/app.py
  - tests/test_digest.py
  - tests/test_app.py
autonomous: true
gap_closure: true
requirements: [DEPLOY-06]

must_haves:
  truths:
    - "POST /digest with valid auth returns 200 even when Notion/Slack credentials are missing or invalid"
    - "POST /digest with valid auth returns a structured error response (not 500) when external APIs fail"
    - "send_weekly_digest catches exceptions from Notion and Slack calls and returns a meaningful error dict"
  artifacts:
    - path: "src/knowledge_hub/digest.py"
      provides: "Error-handled send_weekly_digest and check_daily_cost"
      contains: "try"
    - path: "src/knowledge_hub/app.py"
      provides: "Error-handled /digest endpoint"
      contains: "try"
    - path: "tests/test_digest.py"
      provides: "Tests for error paths in send_weekly_digest and check_daily_cost"
      contains: "test_send_weekly_digest_notion_error"
    - path: "tests/test_app.py"
      provides: "Test for /digest returning structured error when digest function fails"
      contains: "test_digest_endpoint_internal_error"
  key_links:
    - from: "src/knowledge_hub/app.py"
      to: "src/knowledge_hub/digest.py"
      via: "try/except around send_weekly_digest() call"
      pattern: "try.*send_weekly_digest"
    - from: "src/knowledge_hub/digest.py"
      to: "Notion/Slack APIs"
      via: "try/except around query_recent_entries and chat_postMessage"
      pattern: "except.*Exception"
---

<objective>
Fix POST /digest returning HTTP 500 when Notion/Slack credentials are not configured or external APIs fail.

Purpose: The /digest endpoint crashes with an unhandled exception because send_weekly_digest() unconditionally calls Notion and Slack APIs with no error handling. When credentials are empty strings (local dev, misconfigured deployment), these API calls fail and the exception propagates as HTTP 500. The /cost-check endpoint works because it only reads in-memory data and conditionally calls Slack.

Output: Both /digest and /cost-check endpoints return structured JSON responses (never 500) regardless of external service availability.
</objective>

<execution_context>
@/Users/dbenger/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dbenger/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-cloud-run-deployment/07-03-SUMMARY.md
@.planning/debug/digest-500-no-credentials.md

@src/knowledge_hub/digest.py
@src/knowledge_hub/app.py
@tests/test_digest.py
@tests/test_app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add error handling to digest.py and app.py</name>
  <files>src/knowledge_hub/digest.py, src/knowledge_hub/app.py</files>
  <action>
Two layers of defense needed. Apply both:

**Layer 1 -- digest.py: Wrap external calls in send_weekly_digest()**

In `send_weekly_digest()`, wrap the Notion query in a try/except:
```python
try:
    pages = await query_recent_entries(days=7)
    entries = [_extract_entry_data(page) for page in pages]
except Exception as e:
    logger.error("Failed to query Notion for digest", extra={"error": str(e)})
    return {"status": "error", "error": f"Failed to query Notion: {e}"}
```

After building the message, wrap the Slack send in a try/except:
```python
try:
    client = await get_slack_client()
    await client.chat_postMessage(
        channel=settings.allowed_user_id,
        text=message,
    )
except Exception as e:
    logger.error("Failed to send digest via Slack", extra={"error": str(e), "entries": len(entries)})
    return {"status": "error", "error": f"Failed to send Slack message: {e}", "entries": len(entries)}
```

The `get_weekly_cost()` and `reset_weekly_cost()` calls are in-memory and will not fail, so they do not need wrapping. Keep `reset_weekly_cost()` ONLY in the success path (after Slack send succeeds) -- do NOT reset if Slack send failed.

Similarly in `check_daily_cost()`, wrap the Slack alert send (inside the `if cost > 5.0` block) in a try/except:
```python
try:
    client = await get_slack_client()
    await client.chat_postMessage(
        channel=settings.allowed_user_id,
        text=f"Daily Gemini cost alert: ${cost:.2f} exceeds $5.00 threshold",
    )
except Exception as e:
    logger.error("Failed to send cost alert via Slack", extra={"error": str(e), "cost_usd": round(cost, 6)})
    return {"status": "error", "error": f"Failed to send cost alert: {e}", "cost": cost}
```

**Layer 2 -- app.py: Catch exceptions in endpoint handlers**

This is defense-in-depth. Even though digest.py now handles errors, the endpoint should never let an unhandled exception become 500.

In the `/digest` endpoint:
```python
@app.post("/digest")
async def digest_endpoint(_: None = Depends(verify_scheduler)):
    """Trigger weekly digest: query Notion, build summary, send Slack DM."""
    try:
        result = await send_weekly_digest()
        return result
    except Exception as e:
        logger.error("Digest endpoint failed", extra={"error": str(e)})
        return {"status": "error", "error": str(e)}
```

In the `/cost-check` endpoint:
```python
@app.post("/cost-check")
async def cost_check_endpoint(_: None = Depends(verify_scheduler)):
    """Trigger daily cost check: alert if Gemini spend exceeds threshold."""
    try:
        result = await check_daily_cost()
        return result
    except Exception as e:
        logger.error("Cost check endpoint failed", extra={"error": str(e)})
        return {"status": "error", "error": str(e)}
```

Add `import logging` to app.py and create a module logger: `logger = logging.getLogger(__name__)`.

IMPORTANT: Do NOT change the verify_scheduler dependency or health endpoint. Do NOT change any function signatures. Do NOT change the happy-path return values.
  </action>
  <verify>Run `uv run python -c "from knowledge_hub.digest import send_weekly_digest; from knowledge_hub.app import app; print('imports ok')"` to confirm no syntax errors.</verify>
  <done>send_weekly_digest() catches Notion and Slack exceptions and returns {"status": "error", ...}. check_daily_cost() catches Slack exceptions. Both /digest and /cost-check endpoints have defense-in-depth try/except that returns 200 with error status instead of 500.</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for error handling paths</name>
  <files>tests/test_digest.py, tests/test_app.py</files>
  <action>
**In tests/test_digest.py, add 3 new tests after the existing tests:**

1. `test_send_weekly_digest_notion_error` -- Patch `query_recent_entries` to raise `Exception("Notion API auth failed")`. Assert `send_weekly_digest()` returns `{"status": "error", "error": ...}` with "Notion" in the error string. Assert it does NOT call `get_slack_client` (Slack should not be attempted if Notion fails). Assert `reset_weekly_cost` is NOT called (don't reset on failure).

2. `test_send_weekly_digest_slack_error` -- Patch `query_recent_entries` to return `[_make_notion_page()]` (success). Patch `get_slack_client` to return an AsyncMock whose `chat_postMessage` raises `Exception("Slack token invalid")`. Assert return is `{"status": "error", "error": ...}` with "Slack" in the error string and `"entries"` key present. Assert `reset_weekly_cost` is NOT called.

3. `test_check_daily_cost_slack_error` -- Patch `get_daily_cost` to return `7.0` (over threshold). Patch `get_slack_client` to return an AsyncMock whose `chat_postMessage` raises `Exception("Slack error")`. Assert return is `{"status": "error", "error": ...}` with the cost value present.

All three are async tests (use `@pytest.mark.asyncio`). Follow existing test patterns: use `unittest.mock.patch` as context managers, patch at `knowledge_hub.digest.*` module path.

**In tests/test_app.py, add 1 new test:**

4. `test_digest_endpoint_internal_error` -- With valid auth (patch `get_settings` to return scheduler_secret="test-secret"), patch `send_weekly_digest` to raise `Exception("unexpected")`. Assert the response status_code is 200 (NOT 500) and the body contains `{"status": "error", ...}`.

Follow existing test_app.py patterns: use `client` fixture, `patch("knowledge_hub.app.get_settings")` and `patch("knowledge_hub.app.send_weekly_digest")`.

After adding tests, run `uv run pytest tests/test_digest.py tests/test_app.py -v` to confirm all pass. Then run `uv run pytest` to confirm full suite still passes (should be 235 total: 231 + 4 new).
  </action>
  <verify>Run `uv run pytest tests/test_digest.py tests/test_app.py -v` -- all tests pass including the 4 new error-handling tests. Run `uv run pytest` -- full suite passes with 235 tests.</verify>
  <done>4 new tests cover: Notion failure in digest, Slack failure in digest, Slack failure in cost alert, and defense-in-depth 500 prevention in app.py. Total test count is 235, all passing.</done>
</task>

</tasks>

<verification>
1. `uv run pytest` passes with 235 tests (231 existing + 4 new)
2. Start the app locally without Notion/Slack credentials: `uv run uvicorn knowledge_hub.app:app --port 8080` then `curl -X POST http://localhost:8080/digest -H "X-Scheduler-Secret: test" -H "Content-Type: application/json"` returns 200 with `{"status": "error", ...}` (not 500)
3. The /cost-check endpoint still returns `{"status": "ok", "cost": 0.0}` (unchanged behavior when under threshold)
</verification>

<success_criteria>
POST /digest with valid auth returns 200 with a structured JSON body (either success or error) regardless of whether Notion/Slack credentials are configured. The endpoint never returns HTTP 500 from unhandled exceptions. All 235 tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/07-cloud-run-deployment/07-04-SUMMARY.md`
</output>
