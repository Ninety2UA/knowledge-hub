---
phase: 06-pipeline-integration
plan: 02
type: tdd
wave: 2
depends_on: ["06-01"]
files_modified:
  - tests/test_slack/test_client.py
  - tests/test_slack/test_notifier.py
  - tests/test_slack/test_pipeline.py
  - tests/test_llm/test_prompts.py
autonomous: true
requirements: [NOTIFY-01, NOTIFY-02, NOTIFY-03, NOTIFY-04]

must_haves:
  truths:
    - "Slack client singleton initializes from settings and resets for testing"
    - "notify_success sends a thread reply with the Notion page link"
    - "notify_error sends a thread reply with the stage and error detail"
    - "notify_duplicate sends a thread reply with the existing page link"
    - "add_reaction calls reactions_add and handles missing_scope and already_reacted gracefully"
    - "Notification failures never raise exceptions"
    - "Pipeline processes each URL independently -- one failure does not abort others"
    - "Pipeline adds checkmark reaction when all URLs succeed, X when any fails"
    - "Failed extraction skips LLM and Notion stages, sends error notification"
    - "Duplicate URL sends duplicate notification, not error"
    - "build_user_content includes user_note when present"
  artifacts:
    - path: "tests/test_slack/test_client.py"
      provides: "Slack client singleton tests"
      min_lines: 30
    - path: "tests/test_slack/test_notifier.py"
      provides: "Notification function tests (success, error, duplicate, reaction)"
      min_lines: 80
    - path: "tests/test_slack/test_pipeline.py"
      provides: "End-to-end pipeline orchestration tests"
      min_lines: 100
    - path: "tests/test_llm/test_prompts.py"
      provides: "Updated prompt tests including user_note"
      min_lines: 20
  key_links:
    - from: "tests/test_slack/test_notifier.py"
      to: "knowledge_hub.slack.notifier"
      via: "AsyncMock for get_slack_client"
      pattern: "patch.*get_slack_client"
    - from: "tests/test_slack/test_pipeline.py"
      to: "knowledge_hub.slack.handlers.process_message_urls"
      via: "AsyncMock for extract_content, process_content, create_notion_page, notifier"
      pattern: "patch.*extract_content"
---

<objective>
Comprehensive test suite for the Phase 6 integration layer: Slack client, notifier, and full pipeline orchestration.

Purpose: Verify all four NOTIFY requirements are correctly implemented, all error paths are covered, and the pipeline processes URLs independently with proper notification behavior.

Output: Test files covering Slack client singleton, all notifier functions, pipeline success/failure/duplicate flows, and user_note propagation.
</objective>

<execution_context>
@/Users/dbenger/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dbenger/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-pipeline-integration/06-RESEARCH.md
@.planning/phases/06-pipeline-integration/06-01-SUMMARY.md
@src/knowledge_hub/slack/client.py
@src/knowledge_hub/slack/notifier.py
@src/knowledge_hub/slack/handlers.py
@src/knowledge_hub/models/content.py
@src/knowledge_hub/llm/prompts.py
@tests/test_slack/test_handlers.py
@tests/test_llm/test_prompts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD tests for Slack client and notifier</name>
  <files>
    tests/test_slack/test_client.py
    tests/test_slack/test_notifier.py
  </files>
  <action>
**1. Create `tests/test_slack/test_client.py`** with these tests:

- `test_get_slack_client_creates_client` -- patch `get_settings` to return mock settings with `slack_bot_token="xoxb-test"`, call `get_slack_client()`, assert returns `AsyncWebClient` instance
- `test_get_slack_client_returns_cached` -- call twice, assert same object (is identity check)
- `test_reset_client_clears_cache` -- call `get_slack_client()`, then `reset_client()`, call again, assert different object
- Use `pytest.fixture(autouse=True)` to call `reset_client()` before each test to prevent singleton leakage
- Mark async tests with `@pytest.mark.asyncio`

**2. Create `tests/test_slack/test_notifier.py`** with these tests:

Mock `get_slack_client` to return an `AsyncMock` in all tests. Use `@pytest.fixture` pattern.

**notify_success tests:**
- `test_notify_success_sends_thread_reply` -- call `notify_success(channel, ts, PageResult(...))`, assert `client.chat_postMessage` called once with `channel=channel`, `thread_ts=ts`, and text containing the page URL and title
- `test_notify_success_swallows_slack_error` -- make `chat_postMessage` raise `SlackApiError(response={"error": "not_in_channel"})`, assert no exception raised

**notify_error tests:**
- `test_notify_error_sends_thread_reply_with_stage` -- call `notify_error(channel, ts, url, "extraction", "timed out")`, assert text contains the URL, "extraction", and "timed out"
- `test_notify_error_swallows_slack_error` -- same pattern as success

**notify_duplicate tests:**
- `test_notify_duplicate_sends_existing_link` -- call with `DuplicateResult(page_id="x", page_url="https://notion.so/x", title="Existing")`, assert text contains the page URL and title
- `test_notify_duplicate_swallows_slack_error` -- same pattern

**add_reaction tests:**
- `test_add_reaction_calls_reactions_add` -- call `add_reaction(channel, ts, "white_check_mark")`, assert `client.reactions_add` called with correct args
- `test_add_reaction_handles_missing_scope` -- raise `SlackApiError(response={"error": "missing_scope"})`, assert no exception
- `test_add_reaction_handles_already_reacted` -- raise `SlackApiError(response={"error": "already_reacted"})`, assert no exception

For constructing `SlackApiError` in tests: `SlackApiError(message="error", response=SlackResponse(client=None, http_verb="POST", api_url="", req_args={}, data={"ok": False, "error": "missing_scope"}, headers={}, status_code=200))`. Import from `slack_sdk.errors` and `slack_sdk.web.slack_response`. Alternatively, use `MagicMock` for the response object with `response.get("error")` returning the error code and `response["error"]` returning the error code. Check how `SlackApiError` is constructed in the SDK -- it takes `message` and `response` params. The `response` can be a mock with `.data` dict containing `{"ok": False, "error": "..."}`. The simplest approach: create a mock response with a `__getitem__` that returns the error code, or use the actual `SlackResponse` class.

Use `unittest.mock.patch` on `knowledge_hub.slack.notifier.get_slack_client` for isolation.
  </action>
  <verify>
- `pytest tests/test_slack/test_client.py tests/test_slack/test_notifier.py -v` -- all tests pass
- `ruff check tests/test_slack/test_client.py tests/test_slack/test_notifier.py` -- lint clean
  </verify>
  <done>
Slack client singleton has 3 tests covering init, caching, and reset. Notifier has 9 tests covering all 4 functions (success, error, duplicate, reaction) plus graceful error handling for SlackApiError (missing_scope, already_reacted, not_in_channel). All notification functions are verified to never raise.
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD tests for pipeline orchestration and user_note propagation</name>
  <files>
    tests/test_slack/test_pipeline.py
    tests/test_llm/test_prompts.py
  </files>
  <action>
**1. Create `tests/test_slack/test_pipeline.py`** testing `process_message_urls` end-to-end with all external calls mocked.

Use `unittest.mock.patch` to mock these in every test:
- `knowledge_hub.slack.handlers.resolve_urls` (async -- return resolved URLs)
- `knowledge_hub.slack.handlers.extract_content` (async -- return ExtractedContent)
- `knowledge_hub.slack.handlers.get_gemini_client` (sync -- return Mock)
- `knowledge_hub.slack.handlers.process_content` (async -- return NotionPage)
- `knowledge_hub.slack.handlers.create_notion_page` (async -- return PageResult or DuplicateResult)
- `knowledge_hub.slack.handlers.notify_success` (async)
- `knowledge_hub.slack.handlers.notify_error` (async)
- `knowledge_hub.slack.handlers.notify_duplicate` (async)
- `knowledge_hub.slack.handlers.add_reaction` (async)

Create helper factories:
- `_make_content(url, status=ExtractionStatus.FULL)` -- returns ExtractedContent
- `_make_page_result(url)` -- returns PageResult
- `_make_duplicate_result(url)` -- returns DuplicateResult

**Tests (all async):**

- `test_single_url_success_pipeline` -- one URL, extraction FULL, create_notion_page returns PageResult. Assert: extract_content called, process_content called, create_notion_page called, notify_success called with PageResult, add_reaction called with "white_check_mark"
- `test_single_url_failed_extraction` -- extraction returns FAILED status. Assert: process_content NOT called, create_notion_page NOT called, notify_error called with stage="extraction", add_reaction called with "x"
- `test_single_url_duplicate` -- create_notion_page returns DuplicateResult. Assert: notify_duplicate called with DuplicateResult, notify_success NOT called, add_reaction called with "white_check_mark" (duplicate is not a failure)
- `test_single_url_llm_exception` -- process_content raises Exception. Assert: notify_error called, add_reaction called with "x"
- `test_single_url_notion_exception` -- create_notion_page raises Exception. Assert: notify_error called, add_reaction called with "x"
- `test_multi_url_all_succeed` -- 2 URLs, both succeed. Assert: notify_success called twice, add_reaction called once with "white_check_mark"
- `test_multi_url_partial_failure` -- 2 URLs, first succeeds, second fails extraction. Assert: notify_success called once, notify_error called once, add_reaction called with "x"
- `test_user_note_passed_to_content` -- single URL with user_note="context here". Assert: after extract_content returns, `content.user_note` is set to "context here" before process_content is called. Capture the content object passed to process_content via mock side_effect.
- `test_classify_stage_extraction` -- call `_classify_stage` with mock exception whose `__module__` contains "extraction", assert returns "extraction"
- `test_classify_stage_llm` -- module contains "genai", assert "llm"
- `test_classify_stage_notion` -- module contains "notion", assert "notion"
- `test_classify_stage_unknown` -- module is "builtins", assert "processing"

**2. Update `tests/test_llm/test_prompts.py`** (or create if needed) to add user_note tests:

- `test_build_user_content_with_user_note` -- create ExtractedContent with user_note="Check this for Q3", assert `build_user_content()` output contains "User Note: Check this for Q3"
- `test_build_user_content_without_user_note` -- create ExtractedContent with user_note=None, assert output does NOT contain "User Note"

Check if `tests/test_llm/test_prompts.py` already exists. If it does, add the new tests to it. If not, create it.
  </action>
  <verify>
- `pytest tests/test_slack/test_pipeline.py tests/test_llm/test_prompts.py -v` -- all new tests pass
- `pytest tests/ -x` -- full suite (183 existing + all new) passes with 0 regressions
- `ruff check tests/test_slack/ tests/test_llm/` -- lint clean
  </verify>
  <done>
Pipeline orchestration has 12 tests covering: success path, failed extraction, duplicate URL, LLM exception, Notion exception, multi-URL success, multi-URL partial failure, user_note propagation, and stage classification. Prompt tests verify user_note inclusion and exclusion. Full test suite passes with 0 regressions.
  </done>
</task>

</tasks>

<verification>
1. All new tests pass: `pytest tests/test_slack/test_client.py tests/test_slack/test_notifier.py tests/test_slack/test_pipeline.py tests/test_llm/test_prompts.py -v`
2. Full test suite passes: `pytest tests/ -x`
3. Lint clean: `ruff check tests/`
4. Test count increased by ~24 tests (3 client + 9 notifier + 12 pipeline + 2 prompts = 26)
</verification>

<success_criteria>
- Slack client singleton tested: init, caching, reset (3 tests)
- All 4 notifier functions tested with success and error paths (9 tests)
- Pipeline tested for: single success, failed extraction, duplicate, LLM error, Notion error, multi-URL success, multi-URL partial failure, user_note forwarding, stage classification (12 tests)
- Prompt user_note inclusion tested (2 tests)
- All notification functions verified to swallow SlackApiError (never raise)
- Full test suite (183 + ~26 new) passes with 0 regressions
</success_criteria>

<output>
After completion, create `.planning/phases/06-pipeline-integration/06-02-SUMMARY.md`
</output>
