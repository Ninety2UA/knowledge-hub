---
phase: 02-slack-ingress
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/knowledge_hub/config.py
  - src/knowledge_hub/slack/__init__.py
  - src/knowledge_hub/slack/verification.py
  - src/knowledge_hub/slack/urls.py
  - src/knowledge_hub/slack/handlers.py
  - src/knowledge_hub/slack/router.py
  - src/knowledge_hub/app.py
autonomous: true
requirements:
  - INGEST-01
  - INGEST-02
  - INGEST-03
  - INGEST-04
  - INGEST-05
  - INGEST-06
  - INGEST-07
  - INGEST-08

must_haves:
  truths:
    - "POST /slack/events accepts Slack webhook payloads and returns 200"
    - "URL verification challenge returns the challenge token"
    - "Bot messages, edits, thread replies, and non-allowed users are silently ignored"
    - "URLs are extracted from Slack mrkdwn angle-bracket format"
    - "Non-URL text is captured as user_note"
    - "Shortened URLs are resolved through redirects before dispatch"
    - "Multiple URLs in one message are capped at 10 and dispatched in parallel"
    - "Slack request signatures are verified via slack-sdk"
  artifacts:
    - path: "src/knowledge_hub/slack/router.py"
      provides: "POST /slack/events endpoint"
      min_lines: 15
    - path: "src/knowledge_hub/slack/verification.py"
      provides: "Slack signature verification dependency"
      min_lines: 20
    - path: "src/knowledge_hub/slack/urls.py"
      provides: "URL extraction, user note extraction, redirect resolution"
      min_lines: 40
    - path: "src/knowledge_hub/slack/handlers.py"
      provides: "Event dispatch and message filtering logic"
      min_lines: 50
  key_links:
    - from: "src/knowledge_hub/app.py"
      to: "src/knowledge_hub/slack/router.py"
      via: "app.include_router(slack_router)"
      pattern: "include_router"
    - from: "src/knowledge_hub/slack/router.py"
      to: "src/knowledge_hub/slack/verification.py"
      via: "Depends(verify_slack_request)"
      pattern: "Depends.*verify_slack_request"
    - from: "src/knowledge_hub/slack/handlers.py"
      to: "src/knowledge_hub/slack/urls.py"
      via: "extract_urls() and resolve_urls() calls"
      pattern: "extract_urls|resolve_urls"
    - from: "src/knowledge_hub/slack/verification.py"
      to: "src/knowledge_hub/config.py"
      via: "get_settings() for signing secret"
      pattern: "get_settings"
---

<objective>
Implement the Slack ingress layer: webhook endpoint, signature verification, URL extraction, redirect resolution, message filtering, and background task dispatch.

Purpose: Enable the system to receive Slack messages from #knowledge-inbox, verify their authenticity, extract clean URLs, resolve redirects, and dispatch processing to background tasks -- all while ACKing Slack within 3 seconds.

Output: 6 source files (verification.py, urls.py, handlers.py, router.py) + 2 updated files (config.py, app.py, pyproject.toml)
</objective>

<execution_context>
@/Users/dbenger/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dbenger/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-slack-ingress/02-CONTEXT.md
@.planning/phases/02-slack-ingress/02-RESEARCH.md
@src/knowledge_hub/config.py
@src/knowledge_hub/app.py
@src/knowledge_hub/models/slack.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and update config</name>
  <files>pyproject.toml, src/knowledge_hub/config.py</files>
  <action>
1. Add production dependencies to pyproject.toml:
   - Run `uv add slack-sdk` to add slack-sdk as a production dependency
   - Run `uv add httpx` to promote httpx from dev-only to production dependency (it stays in dev too for TestClient)
   - Verify pyproject.toml now has both `slack-sdk` and `httpx` in `[project] dependencies`

2. Update `src/knowledge_hub/config.py` Settings class:
   - Add `allowed_user_id: str = ""` field under the `# Slack` section comment
   - This is the Slack user ID filter -- only messages from this user are processed
   - Keep empty string default (fail-closed: if not set, no messages match)
   - No other config changes needed (`slack_signing_secret` already exists from Phase 1)
  </action>
  <verify>
- `uv run python -c "from slack_sdk.signature import SignatureVerifier; print('OK')"` succeeds
- `uv run python -c "import httpx; print('OK')"` succeeds
- `uv run python -c "from knowledge_hub.config import Settings; s = Settings(); print(s.allowed_user_id)"` prints empty string
  </verify>
  <done>slack-sdk and httpx are production dependencies; Settings has allowed_user_id field with empty string default</done>
</task>

<task type="auto">
  <name>Task 2: Implement Slack ingress modules and wire router</name>
  <files>src/knowledge_hub/slack/__init__.py, src/knowledge_hub/slack/verification.py, src/knowledge_hub/slack/urls.py, src/knowledge_hub/slack/handlers.py, src/knowledge_hub/slack/router.py, src/knowledge_hub/app.py</files>
  <action>
1. Create `src/knowledge_hub/slack/verification.py`:
   - FastAPI dependency function `verify_slack_request(request: Request) -> dict`
   - Read raw body with `await request.body()` FIRST (before any JSON parsing)
   - Get `X-Slack-Request-Timestamp` and `X-Slack-Signature` headers
   - Use `slack_sdk.signature.SignatureVerifier(signing_secret=settings.slack_signing_secret)` to verify
   - Call `verifier.is_valid(body=body, timestamp=timestamp, signature=signature)`
   - Raise `HTTPException(status_code=403, detail="Invalid Slack signature")` on failure
   - Return `await request.json()` on success
   - Import settings via `get_settings()`

2. Create `src/knowledge_hub/slack/urls.py`:
   - Constants: `SLACK_URL_PATTERN = re.compile(r"<(https?://[^|>]+)(?:\|[^>]*)?>")` -- matches `<url>` and `<url|label>` but NOT `<@U123>`, `<#C123>`, `<!here>`
   - `extract_urls(text: str) -> list[str]` -- return all URL matches from Slack mrkdwn text
   - `extract_user_note(text: str) -> str | None` -- remove all URL markup from text, strip whitespace, return None if empty
   - `resolve_url(url: str) -> str | None` -- async function using `httpx.AsyncClient(follow_redirects=True, max_redirects=5, timeout=httpx.Timeout(10.0))`. Use GET request (not HEAD -- some shorteners reject HEAD per research Pitfall 6). Return `str(response.url)` on success, `None` on any `httpx.HTTPError` or `httpx.TooManyRedirects`
   - `resolve_urls(urls: list[str]) -> list[str]` -- resolve all URLs in parallel with `asyncio.gather(*[resolve_url(u) for u in urls], return_exceptions=True)`. Filter results: keep only `str` values (skip None and exceptions)

3. Create `src/knowledge_hub/slack/handlers.py`:
   - `handle_slack_event(payload: dict, background_tasks: BackgroundTasks) -> JSONResponse` -- main dispatch:
     - If `payload["type"] == "url_verification"`: return `JSONResponse({"challenge": payload["challenge"]})`
     - If `payload["type"] == "event_callback"`: extract event dict, call `handle_message_event()`
     - Default: return `JSONResponse({"ok": True})`
   - Also check `X-Slack-Retry-Num` header: if present, return 200 immediately (dedup retries per research Pitfall 3). Pass `request` to handler or check in router.
   - `handle_message_event(event: dict, background_tasks: BackgroundTasks) -> None` -- apply filters IN ORDER:
     a. `event.get("type") != "message"` -> return (not a message)
     b. `event.get("subtype") is not None` -> return (edits, bot_message, joins, etc.)
     c. `event.get("bot_id")` -> return (belt-and-suspenders bot filter)
     d. `event.get("user") != settings.allowed_user_id` -> return (wrong user)
     e. `event.get("thread_ts")` -> return (thread reply, not top-level)
     f. Extract URLs via `extract_urls(text)`. If empty -> return
     g. Cap URLs at 10: `urls = urls[:10]`
     h. Extract user note via `extract_user_note(text)`
     i. Dispatch to background: `background_tasks.add_task(process_message_urls, channel_id=event["channel"], timestamp=event["ts"], user_id=event["user"], text=text, urls=urls, user_note=user_note)`
   - `process_message_urls(...)` -- async stub that resolves URLs via `resolve_urls()`, then for each resolved URL creates a `SlackEvent` model instance. This is the handoff point for Phase 3+. For now, just resolve URLs and log (or pass). Import `SlackEvent` from `knowledge_hub.models`.
   - Use `get_settings()` for `allowed_user_id`

4. Create `src/knowledge_hub/slack/router.py`:
   - `router = APIRouter(prefix="", tags=["slack"])` -- no prefix since route is `/slack/events`
   - Single endpoint: `@router.post("/slack/events")`
   - Parameters: `request: Request, background_tasks: BackgroundTasks, payload: dict = Depends(verify_slack_request)`
   - Check `request.headers.get("X-Slack-Retry-Num")` -- if present, return `JSONResponse({"ok": True})` immediately
   - Otherwise call `handle_slack_event(payload, background_tasks)` and return result

5. Update `src/knowledge_hub/slack/__init__.py`:
   - Update docstring to reflect implemented modules
   - Import and expose `router` for convenience: `from knowledge_hub.slack.router import router`

6. Update `src/knowledge_hub/app.py`:
   - Add `from knowledge_hub.slack.router import router as slack_router`
   - Add `app.include_router(slack_router)` after the app is created (before health endpoint definition, or after -- order doesn't matter for include_router)
  </action>
  <verify>
- `uv run python -c "from knowledge_hub.slack.verification import verify_slack_request; print('OK')"` succeeds
- `uv run python -c "from knowledge_hub.slack.urls import extract_urls, extract_user_note, resolve_urls; print('OK')"` succeeds
- `uv run python -c "from knowledge_hub.slack.handlers import handle_slack_event; print('OK')"` succeeds
- `uv run python -c "from knowledge_hub.slack.router import router; print(router.routes)"` shows the /slack/events route
- `uv run python -c "from knowledge_hub.app import app; routes = [r.path for r in app.routes]; assert '/slack/events' in routes; print('OK')"` succeeds
- `uv run ruff check src/knowledge_hub/slack/` passes with no errors
  </verify>
  <done>All 4 Slack modules implemented (verification, urls, handlers, router), router registered in app, imports clean, linter passes. POST /slack/events endpoint exists and is wired.</done>
</task>

</tasks>

<verification>
1. All imports resolve without errors: `uv run python -c "from knowledge_hub.slack import router"`
2. App includes the slack router: `uv run python -c "from knowledge_hub.app import app; print([r.path for r in app.routes])"`
3. Linter clean: `uv run ruff check src/`
4. Health endpoint still works: `uv run pytest tests/test_health.py -v`
5. Existing tests still pass: `uv run pytest tests/ -v`
</verification>

<success_criteria>
- POST /slack/events endpoint is registered in the FastAPI app
- Slack signature verification dependency reads raw body first, verifies with slack-sdk
- URL extraction regex handles both `<url>` and `<url|label>` patterns, excludes user/channel refs
- User note extraction strips URL markup and returns cleaned text
- Redirect resolution uses httpx async with 10s timeout and 5 max redirects, GET method
- Message filters applied in correct order: type, subtype, bot_id, allowed_user, thread_ts, URLs
- URLs capped at 10 per message
- Slack retries (X-Slack-Retry-Num header) return 200 immediately
- Background task dispatches process_message_urls with all required fields
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-slack-ingress/02-01-SUMMARY.md`
</output>
